<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184 Spring 2026 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Calvin Lee</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-kalevyne/">cal-cs184-student.github.io/hw-webpages-kalevyne/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw-webpages-kalevyne/tree/main">github.com/cal-cs184-student/hw-webpages-kalevyne/tree/main</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this project, I implemented triangular rasterization beginning with just single color triangles, antialiasing via supersampling, geometric transforms, barycentric color interpolation, texture mapping with nearest and bilinear sampling, and mipmap-based level sampling. Triangles are rasterized using bounding boxes, and supersampling and bilinear filtering reduce jagged edges and smooth textures. Barycentric coordinates allowed for smooth color interpolation across triangles, while texture mapping and mipmaps handle detailed textures with minimal aliasing. 

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To draw a single-color triangle, rasterization is used. In this process, three coordinates are given in space, creating a triangle. Connecting these three coordinates creates three different half-planes. Depending on the direction of traversal of the three lines (either clockwise or counter clockwise), a point within or on the boundary of the triangle will have either all nonnegative or all nonpositive values for the dot product of the vector to that point and the normal of each line. I rasterized triangles by iterating through pixels and evaluating whether the pixel was within the triangle or not, filling in each one that was. 
		<p>The algorithm I used did not span every single pixel in the image. Instead, it took the minimum and maximum x and y coordinates of the triangle, creating a bounding box. Then, the rasterization algorithm was performed only on the pixels within the bounding box. 
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_basic3.png" width="400px"/>
				  <figcaption>svg/basic/test3.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1_basic4.png" width="400px"/>
				  <figcaption>svg/basic/test4.svg.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_basic5.png" width="400px"/>
				  <figcaption>svg/basic/test5.svg.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1_basic6.png" width="400px"/>
				  <figcaption>svg/basic/test6.svg.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p> Shown below is a zoomed in corner of the red triangle in svg/basic/test4.svg. Looking closely, there are jaggies that show up due to the nature of the image, specifically the small angle with the horizontal. </p>
		<figure>
			<img src="t1_basic4-1.png" style="width:50%"/>
		</figure>


		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		The supersampling algorithm starts with the sampling rate, which by default is 1, but takes square values. At a high level, supersampling is an antialiasing method that breaks pixels down into smaller samples, then averages the color values across all samples to obtain the color for that pixel. These smaller samples give a more accurate representation of the makeup of the pixel. Rather than a binary white or red for the full pixel, the pixel is shaded according to the makeup of the samples. 
		<p>To implement this, the sample_buffer, which holds an array of Colors, is expanded to account for the increased number of samples. The rasterization is done on each sample rather than pixel, and the colors are written to this sample_buffer, rather than to a pixel. Then, after rasterization of every sample, the rgb_framebuffer(essentially an array of colors but as a char string for final output) is written to from the sample_buffer. The rgb_framebuffer_target represents the true size of pixels being drawn to, and the resolve_to_framebuffer() function averages each pixelâ€™s subsamples and writes the result to the framebuffer. </p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t2_basic4-1.png" width="400px"/>
				  <figcaption>Sampling Rate = 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t2_basic4-2.png" width="400px"/>
				  <figcaption>Sampling Rate = 2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t2_basic4-3.png" width="400px"/>
				  <figcaption>Sampling Rate = 3</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t2_basic4-4.png" width="400px"/>
				  <figcaption>Sampling Rate = 4</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>Above are screenshots of the sharp red corner of basic/test4.svg. The jaggies are decreased due to the antialiasing, with edges of the triangle having varying shades of red. Specifically, the partially shaded pixels have samples that are within the triangle's edges and other samples that are outside the triangle's edges. </p>

		<h2>Task 3: Transforms</h2>
		After implementing the translate, rotate, and scale transformations, I also implemented a shear transformation. I used all four to make this running cubeman below!
		<figure><img src="t3_my_robot.png" width="400px"/></figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates use a method of extrapolating by representing a point in space as a weighted average of vertices from a triangle. In the below image, a triangle is drawn using three vertices with three different colors. At each point, a color is assigned by the corresponding barycentric coordinates. 
		<figure>
			<img src="t4_basic9.png" style="width:50%"/>
			<figcaption>svg/basic/test9.svg triangle</figcaption>
		</figure>
		<p> 	
		The artifact in the left image is a result of sample points landing on edges, being classified as outside the triangle, and not being assigned a color value. To fix this, doubles were used for more precise edge calculations and a consistent tiebreaker was implemented. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t4_basic7.png" width="400px"/>
				  <figcaption>svg/basic/test7.svg with artifact </figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t4_basic7-2.png" width="400px"/>
				  <figcaption>svg/basic/test7.svg</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Texture mapping determines how to select which color to use at a given pixel by defining where to look at an image in texture space relative to screen space. For example, given triangular coordinates in the shape of a circle in screen space and an image in texture space, texture mapping defines how to obtain where in the image to look based on given coordinates in screen space. 
		<p>
			Pixel sampling takes a point in space and decides how to fetch a color. It was implemented as a means of texture mapping by determining colors at texels based on the texture space coordinates. Nearest pixel sampling takes in coordinates and returns the color of the nearest texel center. Bilinear pixel sampling takes in coordinates and returns a color interpolated in both u and v directions using the nearest four texel color values
		</p>
		<p>
			Below are differences in images using either nearest or bilinear pixel sampling with 1 and 16 samples per pixel. Bilinear sampling at 1 sample per pixel results in antialiasing, creating much smoother lines than nearest sampling at 1 sample per pixel. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t5_texmap6_n1.png" width="400px"/>
				  <figcaption>Nearest, 1 </figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t5_texmap6_b1.png" width="400px"/>
				  <figcaption>Bilinear, 1</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t5_texmap6_n16.png" width="400px"/>
				  <figcaption>Nearest, 16</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t5_texmap6_b16.png" width="400px"/>
				  <figcaption>Bilinear, 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>
		When texture space is magnified or has a lot of detail, there will be a large difference in the methods. Especially if there is high frequency data, nearest vs. bilinear may produce different results. Nearest may have more abrupt singular texels while	bilinear will be much smoother due to the blending of neighboring texels. 	</p>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling creates different representations of an image and determines how detailed those representations should be. To implement level sampling, mipmaps are used. Mipmaps have decreasing dimensions in order to better match when pixels cover many texels, reducing aliasing. 
		<p>
			Using a running clock for rasterization, nearest pixel sampling, level zero sampling, and one sample per pixel is the fastest. It uses less memory, but has worse quality. Using linear pixel sampling uses the same amount of memory, but is slower as more texels are fetched for each pixel. This results in smoother texture. Nearest and Linear level sampling are also slower as they use more mip levels, but result in better antialiasing. Finally, supersampling s down rasterization, increases memory usage, but results in extremely good antialiasing improvement. 
		</p>
		<p>
			Below is an image of me and my family using different combinations of sampling at 1 sample per pixel. Notice that the more expensive methods result in generally smoother images. 
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t6_L0_PN.png" width="400px"/>
				  <figcaption>Level zero, nearest pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t6_L0_PL.png" width="400px"/>
				  <figcaption>Level zero, linear pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t6_LN_PN.png" width="400px"/>
				  <figcaption>Nearest level, nearest pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t6_LN_PL.png" width="400px"/>
				  <figcaption>Nearest level, linear pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		</div>
	</body>
</html>